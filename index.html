<!doctype html>
<html lang="ru">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
Â  <title>WG Archer Run</title>
Â  <script src="https://telegram.org/js/telegram-web-app.js"></script>
Â  <style>
Â  Â  html, body { margin:0; padding:0; height:100%; background:#071024; overflow:hidden; }
Â  Â  body { font-family: Arial, sans-serif; -webkit-user-select:none; user-select:none; touch-action:manipulation; }

Â  Â  /* Ñ„Ğ¸ĞºÑĞ¸Ñ€ÑƒĞµĞ¼ Ğ²Ñ‹ÑĞ¾Ñ‚Ñƒ Ğ¿Ğ¾Ğ´ Telegram iOS */
Â  Â  #app {
Â  Â  Â  position: fixed;
Â  Â  Â  inset: 0;
Â  Â  Â  background: linear-gradient(180deg,#071024,#08183a);
Â  Â  Â  overflow: hidden;
Â  Â  }

Â  Â  /* Ğ˜Ğ³Ñ€Ğ¾Ğ²Ğ°Ñ Ğ·Ğ¾Ğ½Ğ° â€” Ğ’Ğ¡Ğ•Ğ“Ğ”Ğ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ°Ñ */
Â  Â  #gameWrap{
Â  Â  Â  position:absolute;
Â  Â  Â  left: 12px;
Â  Â  Â  right: 12px;
Â  Â  Â  top: 110px; Â  Â  Â  Â  Â  Â  Â  Â  /* Ğ¼ĞµÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ´ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº+ÑÑ‚Ğ°Ñ‚Ñ‹ */
Â  Â  Â  bottom: 92px; Â  Â  Â  Â  Â  Â  Â  /* Ğ¼ĞµÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ´ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ */
Â  Â  Â  border-radius: 16px;
Â  Â  Â  overflow:hidden;
Â  Â  Â  background: radial-gradient(1200px 600px at 30% 20%, rgba(255,255,255,.06), transparent 55%),
Â  Â  Â  Â  Â  Â  Â  Â  Â  linear-gradient(180deg, #071024, #08183a);
Â  Â  Â  box-shadow: 0 18px 55px rgba(0,0,0,.45);
Â  Â  }

Â  Â  canvas { width:100%; height:100%; display:block; }

Â  Â  /* HUD ÑĞ²ĞµÑ€Ñ…Ñƒ */
Â  Â  #topbar{
Â  Â  Â  position:absolute;
Â  Â  Â  left:12px; right:12px; top: 12px;
Â  Â  Â  color: rgba(255,255,255,.92);
Â  Â  }
Â  Â  #title{
Â  Â  Â  display:flex; align-items:center; gap:10px;
Â  Â  Â  font-weight:900; letter-spacing:.4px; font-size:18px;
Â  Â  Â  margin-bottom:10px;
Â  Â  }
Â  Â  #stats{ display:flex; flex-wrap:wrap; gap:8px; }
Â  Â  .chip{
Â  Â  Â  background: rgba(255,255,255,.10);
Â  Â  Â  color: rgba(255,255,255,.85);
Â  Â  Â  padding:8px 10px;
Â  Â  Â  border-radius: 12px;
Â  Â  Â  font-size:14px;
Â  Â  }

Â  Â  /* ĞšĞ½Ğ¾Ğ¿ĞºĞ¸ ÑĞ½Ğ¸Ğ·Ñƒ */
Â  Â  #controls{
Â  Â  Â  position:absolute;
Â  Â  Â  left:12px; right:12px;
Â  Â  Â  bottom: calc(12px + env(safe-area-inset-bottom));
Â  Â  Â  display:flex;
Â  Â  Â  gap:10px;
Â  Â  Â  justify-content:center;
Â  Â  }
Â  Â  button{
Â  Â  Â  border:none;
Â  Â  Â  border-radius:14px;
Â  Â  Â  padding:12px 18px;
Â  Â  Â  font-weight:900;
Â  Â  Â  background: rgba(255,255,255,.92);
Â  Â  Â  color:#061028;
Â  Â  }
Â  Â  button.secondary{
Â  Â  Â  background: rgba(255,255,255,.16);
Â  Â  Â  color: rgba(255,255,255,.92);
Â  Â  }

Â  Â  /* Game Over Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ğ¸Ğ³Ñ€Ñ‹ */
Â  Â  #overlay{
Â  Â  Â  position:absolute; inset:0;
Â  Â  Â  display:flex; flex-direction:column;
Â  Â  Â  align-items:center; justify-content:center;
Â  Â  Â  background: rgba(0,0,0,.55);
Â  Â  Â  color:#fff;
Â  Â  Â  opacity:0; pointer-events:none;
Â  Â  Â  transition:.15s;
Â  Â  Â  text-align:center;
Â  Â  Â  padding:18px;
Â  Â  }
Â  Â  #overlay.show{ opacity:1; pointer-events:auto; }
Â  Â  #overlay h2{ margin:0 0 8px 0; font-size:30px; }
Â  Â  #overlay .sub{ opacity:.9; margin-bottom:14px; }

Â  Â  /* Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ğ¹ toast */
Â  Â  #toast{
Â  Â  Â  position:absolute;
Â  Â  Â  left:50%;
Â  Â  Â  bottom: 14px;
Â  Â  Â  transform:translateX(-50%);
Â  Â  Â  background: rgba(0,0,0,.65);
Â  Â  Â  color:#fff;
Â  Â  Â  padding:10px 12px;
Â  Â  Â  border-radius:12px;
Â  Â  Â  font-weight:900;
Â  Â  Â  font-size:14px;
Â  Â  Â  opacity:0;
Â  Â  Â  transition:.2s;
Â  Â  Â  pointer-events:none;
Â  Â  Â  white-space:nowrap;
Â  Â  Â  max-width:92%;
Â  Â  Â  overflow:hidden;
Â  Â  Â  text-overflow:ellipsis;
Â  Â  }
Â  Â  #toast.show{ opacity:1; }
Â  </style>
</head>

<body>
<div id="app">

Â  <div id="topbar">
Â  Â  <div id="title">ğŸ¹ <span>WG Archer Run</span></div>
Â  Â  <div id="stats">
Â  Â  Â  <div class="chip">â± <span id="time">0.0</span> ÑĞµĞº</div>
Â  Â  Â  <div class="chip">ğŸ <span id="dist">0</span> Ğ¼</div>
Â  Â  Â  <div class="chip">âš¡ <span id="spd">1.0</span>x</div>
Â  Â  Â  <div class="chip">ğŸ† Ğ ĞµĞºĞ¾Ñ€Ğ´: <span id="best">0</span> Ğ¼</div>
Â  Â  </div>
Â  </div>

Â  <div id="gameWrap">
Â  Â  <canvas id="c"></canvas>

Â  Â  <div id="overlay">
Â  Â  Â  <h2>GAME OVER</h2>
Â  Â  Â  <div class="sub">Ğ”Ğ¸ÑÑ‚Ğ°Ğ½Ñ†Ğ¸Ñ: <b><span id="ovDist">0</span> Ğ¼</b></div>
Â  Â  Â  <div style="display:flex; gap:10px; margin-top:10px;">
Â  Â  Â  Â  <button id="again">Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ</button>
Â  Â  Â  Â  <button class="secondary" id="reset2">Ğ¡Ğ±Ñ€Ğ¾Ñ</button>
Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="toast"></div>
Â  </div>

Â  <div id="controls">
Â  Â  <button id="play">â–¶ Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ</button>
Â  Â  <button class="secondary" id="reset">â†» Ğ¡Ğ±Ñ€Ğ¾Ñ</button>
Â  </div>

</div>

<script>
(() => {
Â  // Telegram expand + Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ°Ñ Ğ²Ñ‹ÑĞ¾Ñ‚Ğ° iOS
Â  try {
Â  Â  if (window.Telegram && Telegram.WebApp) {
Â  Â  Â  Telegram.WebApp.ready();
Â  Â  Â  Telegram.WebApp.expand();
Â  Â  Â  Telegram.WebApp.setHeaderColor?.("#071024");
Â  Â  Â  Telegram.WebApp.setBackgroundColor?.("#071024");
Â  Â  }
Â  } catch(e){}

Â  const app = document.getElementById('app');
Â  function fixHeight() {
Â  Â  let h = window.innerHeight;
Â  Â  try {
Â  Â  Â  if (window.Telegram && Telegram.WebApp && Telegram.WebApp.viewportHeight) {
Â  Â  Â  Â  h = Telegram.WebApp.viewportHeight;
Â  Â  Â  }
Â  Â  } catch(e){}
Â  Â  app.style.height = h + 'px';
Â  }
Â  window.addEventListener('resize', fixHeight);
Â  fixHeight();

Â  const canvas = document.getElementById('c');
Â  const ctx = canvas.getContext('2d', { alpha:false });

Â  const timeEl = document.getElementById('time');
Â  const distEl = document.getElementById('dist');
Â  const spdEl Â = document.getElementById('spd');
Â  const bestEl = document.getElementById('best');

Â  const overlay = document.getElementById('overlay');
Â  const ovDist = document.getElementById('ovDist');
Â  const toast = document.getElementById('toast');

Â  const playBtn = document.getElementById('play');
Â  const resetBtn = document.getElementById('reset');
Â  const againBtn = document.getElementById('again');
Â  const reset2Btn = document.getElementById('reset2');
Â  const gameWrap = document.getElementById('gameWrap');

Â  // ===== SPRITE SETTINGS (3x3 ÑĞµÑ‚ĞºĞ° ĞºĞ°Ğº Ñ‚Ñ‹ ÑĞºĞ°Ğ·Ğ°Ğ»)
Â  const SPRITE_SRC = 'archer.png';
Â  let FRAME_W = 256;
Â  let FRAME_H = 256;

Â  const RUN_FRAMES = [{x:0,y:0},{x:1,y:0},{x:2,y:0}]; Â  Â  // Ğ²ĞµÑ€Ñ…: Ğ±ĞµĞ³
Â  const START_FRAMES = [{x:0,y:1},{x:1,y:1}]; Â  Â  Â  Â  Â  Â // ÑĞµÑ€ĞµĞ´Ğ¸Ğ½Ğ°: ÑÑ‚Ğ°Ñ€Ñ‚
Â  const DEATH_FRAME = {x:0,y:2}; Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Ğ½Ğ¸Ğ·: ÑĞ¼ĞµÑ€Ñ‚ÑŒ

Â  const img = new Image();
Â  let spriteLoaded = false;
Â  img.onload = () => {
Â  Â  spriteLoaded = true;
Â  Â  // Ğ°Ğ²Ñ‚Ğ¾-Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ğ½ Ğ¿Ğ¾Ğ´ 3x3
Â  Â  if (img.width % 3 === 0) FRAME_W = img.width / 3;
Â  Â  if (img.height % 3 === 0) FRAME_H = img.height / 3;
Â  };
Â  img.src = SPRITE_SRC;

Â  // ===== GAME STATE
Â  const st = {
Â  Â  running:false,
Â  Â  gameOver:false,
Â  Â  t:0,
Â  Â  dist:0,
Â  Â  speed: 280,
Â  Â  speedMul:1.0,
Â  Â  best: Number(localStorage.getItem('wg_best') || 0),
Â  Â  last:0,

Â  Â  groundH: 70,
Â  Â  px: 0, py: 0, pw: 80, ph: 90,
Â  Â  vy: 0, onGround:true,

Â  Â  obstacles: [],
Â  Â  nextSpawn: 0,
Â  Â  minGap: 260,

Â  Â  animMode:'idle', // start/run/death
Â  Â  animTime:0
Â  };

Â  bestEl.textContent = st.best;

Â  function resizeCanvas(){
Â  Â  const r = canvas.getBoundingClientRect();
Â  Â  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
Â  Â  canvas.width = Math.floor(r.width * dpr);
Â  Â  canvas.height = Math.floor(r.height * dpr);
Â  Â  ctx.setTransform(dpr,0,0,dpr,0,0);

Â  Â  const W = r.width, H = r.height;
Â  Â  st.groundH = Math.max(56, Math.round(H*0.16));
Â  Â  st.px = Math.round(W*0.14);
Â  Â  st.ph = Math.round(Math.min(110, Math.max(72, H*0.22)));
Â  Â  st.pw = Math.round(st.ph*0.9);
Â  Â  st.py = H - st.groundH - st.ph;
Â  Â  st.vy = 0;
Â  Â  st.onGround = true;

Â  Â  st.minGap = Math.round(Math.max(W*0.35, 240));
Â  }
Â  window.addEventListener('resize', resizeCanvas);
Â  resizeCanvas();

Â  function drawFrame(frame, x,y,w,h){
Â  Â  if (!spriteLoaded) {
Â  Â  Â  ctx.fillStyle="#fff";
Â  Â  Â  ctx.fillRect(x,y,w,h);
Â  Â  Â  return;
Â  Â  }
Â  Â  const sx = frame.x * FRAME_W;
Â  Â  const sy = frame.y * FRAME_H;
Â  Â  ctx.drawImage(img, sx, sy, FRAME_W, FRAME_H, x,y,w,h);
Â  }

Â  function getAnimFrame(dt){
Â  Â  st.animTime += dt;
Â  Â  if (st.animMode === 'death') return DEATH_FRAME;

Â  Â  if (st.animMode === 'start') {
Â  Â  Â  const idx = Math.floor(st.animTime * 8);
Â  Â  Â  if (idx >= START_FRAMES.length) {
Â  Â  Â  Â  st.animMode = 'run';
Â  Â  Â  Â  st.animTime = 0;
Â  Â  Â  Â  return RUN_FRAMES[0];
Â  Â  Â  }
Â  Â  Â  return START_FRAMES[idx];
Â  Â  }
Â  Â  // run
Â  Â  const idx = Math.floor(st.animTime * 10) % RUN_FRAMES.length;
Â  Â  return RUN_FRAMES[idx];
Â  }

Â  function setNextSpawn(W){
Â  Â  const extra = Math.round(Math.random() * (W*0.25));
Â  Â  st.nextSpawn = st.minGap + extra;
Â  }

Â  function spawnObstacle(W,H){
Â  Â  const base = Math.max(24, Math.round(H*0.08));
Â  Â  const h = base + Math.round(Math.random()*base);
Â  Â  const w = Math.max(18, Math.round(base*0.55));
Â  Â  const x = W + 20;
Â  Â  const y = H - st.groundH - h;
Â  Â  st.obstacles.push({x,y,w,h});
Â  }

Â  function hit(a,b){
Â  Â  return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
Â  }

Â  function toastMsg(text){
Â  Â  toast.textContent = text;
Â  Â  toast.classList.add('show');
Â  Â  clearTimeout(toast._t);
Â  Â  toast._t = setTimeout(()=>toast.classList.remove('show'), 1500);
Â  }

Â  function start(){
Â  Â  overlay.classList.remove('show');
Â  Â  st.running = true;
Â  Â  st.gameOver = false;
Â  Â  st.t = 0;
Â  Â  st.dist = 0;
Â  Â  st.speedMul = 1.0;
Â  Â  st.obstacles = [];
Â  Â  st.animMode = 'start';
Â  Â  st.animTime = 0;
Â  Â  setNextSpawn(canvas.getBoundingClientRect().width);
Â  }

Â  function reset(full=false){
Â  Â  overlay.classList.remove('show');
Â  Â  st.running=false;
Â  Â  st.gameOver=false;
Â  Â  st.t=0;
Â  Â  st.dist=0;
Â  Â  st.speedMul=1.0;
Â  Â  st.obstacles=[];
Â  Â  st.animMode='idle';
Â  Â  st.animTime=0;
Â  Â  if(full){
Â  Â  Â  st.best=0;
Â  Â  Â  localStorage.setItem('wg_best','0');
Â  Â  Â  bestEl.textContent='0';
Â  Â  }
Â  Â  timeEl.textContent='0.0';
Â  Â  distEl.textContent='0';
Â  Â  spdEl.textContent='1.0';
Â  }

Â  function gameOver(){
Â  Â  st.gameOver=true;
Â  Â  st.running=false;
Â  Â  st.animMode='death';
Â  Â  st.animTime=0;
Â  Â  ovDist.textContent = Math.floor(st.dist);
Â  Â  overlay.classList.add('show');
Â  }

Â  function jump(){
Â  Â  if(!st.running || st.gameOver) return;
Â  Â  if(!st.onGround) return;
Â  Â  st.onGround=false;
Â  Â  st.vy = -720;
Â  }

Â  // Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‚Ğ°Ğ¿
Â  function onTap(e){
Â  Â  e.preventDefault();
Â  Â  if(!st.running && !st.gameOver) start();
Â  Â  else jump();
Â  }
Â  gameWrap.addEventListener('touchstart', onTap, {passive:false});
Â  gameWrap.addEventListener('click', (e)=>{ e.preventDefault(); onTap(e); });

Â  playBtn.onclick = start;
Â  againBtn.onclick = start;
Â  resetBtn.onclick = () => reset(false);
Â  reset2Btn.onclick = () => reset(false);

Â  function loop(ts){
Â  Â  requestAnimationFrame(loop);
Â  Â  const r = canvas.getBoundingClientRect();
Â  Â  const W = r.width, H = r.height;
Â  Â  if(!W || !H) return;

Â  Â  const dt = Math.min(0.033, (ts - (st.last||ts))/1000);
Â  Â  st.last = ts;

Â  Â  // Ñ„Ğ¾Ğ½
Â  Â  ctx.fillStyle = '#071024';
Â  Â  ctx.fillRect(0,0,W,H);

Â  Â  // Ğ·ĞµĞ¼Ğ»Ñ
Â  Â  ctx.fillStyle = 'rgba(255,255,255,.10)';
Â  Â  ctx.fillRect(0, H-st.groundH, W, st.groundH);

Â  Â  if(st.running && !st.gameOver){
Â  Â  Â  st.t += dt;

Â  Â  Â  const pxps = st.speed * st.speedMul;
Â  Â  Â  st.dist += (pxps * dt)/6;
Â  Â  Â  st.speedMul = Math.min(2.2, 1.0 + st.dist/3000);

Â  Â  Â  // Ñ„Ğ¸Ğ·Ğ¸ĞºĞ°
Â  Â  Â  st.vy += 1900*dt;
Â  Â  Â  st.py += st.vy*dt;
Â  Â  Â  const gy = H - st.groundH - st.ph;
Â  Â  Â  if(st.py >= gy){
Â  Â  Â  Â  st.py = gy;
Â  Â  Â  Â  st.vy = 0;
Â  Â  Â  Â  st.onGround = true;
Â  Â  Â  }

Â  Â  Â  // Ğ¿Ñ€ĞµĞ¿ÑÑ‚ÑÑ‚Ğ²Ğ¸Ñ
Â  Â  Â  const dx = pxps * dt;
Â  Â  Â  for(const ob of st.obstacles) ob.x -= dx;
Â  Â  Â  st.obstacles = st.obstacles.filter(ob => ob.x+ob.w > -40);

Â  Â  Â  st.nextSpawn -= dx;
Â  Â  Â  if(st.nextSpawn <= 0){
Â  Â  Â  Â  spawnObstacle(W,H);
Â  Â  Â  Â  setNextSpawn(W);
Â  Â  Â  }

Â  Â  Â  // ĞºĞ¾Ğ»Ğ»Ğ¸Ğ·Ğ¸Ğ¸
Â  Â  Â  const pr = {x: st.px+8, y: st.py+6, w: st.pw-16, h: st.ph-10};
Â  Â  Â  for(const ob of st.obstacles){
Â  Â  Â  Â  if(hit(pr, ob)){ gameOver(); break; }
Â  Â  Â  }

Â  Â  Â  // UI
Â  Â  Â  timeEl.textContent = st.t.toFixed(1);
Â  Â  Â  distEl.textContent = Math.floor(st.dist);
Â  Â  Â  spdEl.textContent = st.speedMul.toFixed(1);
Â  Â  }

Â  Â  // Ñ€Ğ¸ÑÑƒĞµĞ¼ Ğ¿Ñ€ĞµĞ¿ÑÑ‚ÑÑ‚Ğ²Ğ¸Ñ (Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ Ğ²Ğ¸Ğ´Ğ½Ğ¾)
Â  Â  ctx.fillStyle = 'rgba(255,70,70,.90)';
Â  Â  for(const ob of st.obstacles){
Â  Â  Â  ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
Â  Â  }

Â  Â  // Ğ¸Ğ³Ñ€Ğ¾Ğº
Â  Â  let frame;
Â  Â  if(st.gameOver) frame = DEATH_FRAME;
Â  Â  else if(!st.running) frame = RUN_FRAMES[0];
Â  Â  else frame = getAnimFrame(dt);

Â  Â  drawFrame(frame, st.px, st.py, st.pw, st.ph);

Â  Â  // Ñ€ĞµĞºĞ¾Ñ€Ğ´
Â  Â  const m = Math.floor(st.dist);
Â  Â  if(m > st.best){
Â  Â  Â  st.best = m;
Â  Â  Â  localStorage.setItem('wg_best', String(m));
Â  Â  Â  bestEl.textContent = String(m);
Â  Â  }
Â  }

Â  reset(false);
Â  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
