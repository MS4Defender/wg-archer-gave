<!doctype html>
<html lang="ru">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
Â  <title>WG Archer Run</title>
Â  <script src="https://telegram.org/js/telegram-web-app.js"></script>
Â  <style>
Â  Â  :root { --bg1:#081225; --bg2:#0b1a33; --panel:rgba(255,255,255,.08); --text:rgba(255,255,255,.92); --muted:rgba(255,255,255,.7); --accent:#6aa6ff; }

Â  Â  html, body { height:100%; margin:0; background:linear-gradient(180deg,var(--bg1),var(--bg2)); overflow:hidden; }
Â  Â  body { -webkit-user-select:none; user-select:none; touch-action:manipulation; font-family:Arial, sans-serif; color:var(--text); }

Â  Â  #app {
Â  Â  Â  height: 100vh;
Â  Â  Â  height: 100svh; /* iOS */
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
Â  Â  Â  box-sizing:border-box;
Â  Â  Â  gap:10px;
Â  Â  }

Â  Â  header { display:flex; align-items:center; justify-content:space-between; gap:10px; }
Â  Â  .title { display:flex; align-items:center; gap:10px; font-weight:900; letter-spacing:.5px; }
Â  Â  .title img { width:22px; height:22px; }

Â  Â  .stats { display:flex; gap:8px; flex-wrap:wrap; }
Â  Â  .chip { background:var(--panel); border-radius:12px; padding:8px 10px; font-size:14px; color:var(--muted); display:flex; gap:6px; align-items:center; }

Â  Â  #gameWrap{
Â  Â  Â  position:relative;
Â  Â  Â  flex:1;
Â  Â  Â  min-height: 260px;
Â  Â  Â  border-radius:16px;
Â  Â  Â  overflow:hidden;
Â  Â  Â  background: radial-gradient(1200px 600px at 30% 20%, rgba(255,255,255,.06), transparent 55%),
Â  Â  Â  Â  Â  Â  Â  Â  Â  linear-gradient(180deg, #071024, #08183a);
Â  Â  Â  box-shadow: 0 18px 55px rgba(0,0,0,.45);
Â  Â  }

Â  Â  canvas { width:100%; height:100%; display:block; }

Â  Â  .controls { display:flex; gap:10px; justify-content:center; }
Â  Â  button{
Â  Â  Â  border:none; border-radius:14px;
Â  Â  Â  padding:12px 18px; font-weight:800;
Â  Â  Â  background: rgba(255,255,255,.9);
Â  Â  Â  color:#061028; cursor:pointer;
Â  Â  }
Â  Â  button.secondary{ background: rgba(255,255,255,.15); color:var(--text); }

Â  Â  /* OVERLAY */
Â  Â  #overlay{
Â  Â  Â  position:absolute; inset:0;
Â  Â  Â  display:flex; flex-direction:column; align-items:center; justify-content:center;
Â  Â  Â  background: rgba(0,0,0,.55);
Â  Â  Â  opacity:0; pointer-events:none;
Â  Â  Â  transition: .18s ease;
Â  Â  Â  text-align:center;
Â  Â  Â  padding:18px;
Â  Â  }
Â  Â  #overlay.show{ opacity:1; pointer-events:auto; }
Â  Â  #overlay h2{ margin:0 0 6px 0; font-size:28px; }
Â  Â  #overlay .sub{ color:rgba(255,255,255,.85); font-size:15px; margin-bottom:14px; }
Â  Â  #overlay .reward{ font-weight:900; color:#b6ffb6; }

Â  Â  /* toast */
Â  Â  #toast{
Â  Â  Â  position:absolute; left:50%; bottom:14px;
Â  Â  Â  transform:translateX(-50%);
Â  Â  Â  background: rgba(0,0,0,.65);
Â  Â  Â  color:#fff; padding:10px 12px; border-radius:12px;
Â  Â  Â  font-weight:800; font-size:14px;
Â  Â  Â  opacity:0; transition:.2s;
Â  Â  Â  pointer-events:none;
Â  Â  Â  max-width: 92%;
Â  Â  Â  text-align:center;
Â  Â  Â  white-space:nowrap;
Â  Â  }
Â  Â  #toast.show{ opacity:1; }

Â  Â  .hint { text-align:center; color:rgba(255,255,255,.55); font-size:12px; }
Â  </style>
</head>
<body>
<div id="app">
Â  <header>
Â  Â  <div class="title">
Â  Â  Â  <span style="font-size:20px;">ğŸ¹</span>
Â  Â  Â  <span>WG Archer Run</span>
Â  Â  </div>
Â  </header>

Â  <div class="stats">
Â  Â  <div class="chip">â± <span id="time">0.0</span> ÑĞµĞº</div>
Â  Â  <div class="chip">ğŸ <span id="dist">0</span> Ğ¼</div>
Â  Â  <div class="chip">âš¡ <span id="spd">1.0</span>x</div>
Â  Â  <div class="chip">ğŸ† Ğ ĞµĞºĞ¾Ñ€Ğ´: <span id="best">0</span> Ğ¼</div>
Â  </div>

Â  <div id="gameWrap">
Â  Â  <canvas id="c"></canvas>

Â  Â  <div id="overlay">
Â  Â  Â  <h2>GAME OVER</h2>
Â  Â  Â  <div class="sub">Ğ”Ğ¸ÑÑ‚Ğ°Ğ½Ñ†Ğ¸Ñ: <b><span id="ovDist">0</span> Ğ¼</b></div>
Â  Â  Â  <div class="reward" id="ovReward"></div>
Â  Â  Â  <div style="margin-top:14px; display:flex; gap:10px;">
Â  Â  Â  Â  <button id="btnAgain">Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ</button>
Â  Â  Â  Â  <button class="secondary" id="btnReset">Ğ¡Ğ±Ñ€Ğ¾Ñ</button>
Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="toast"></div>
Â  </div>

Â  <div class="controls">
Â  Â  <button id="play">â–¶ Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ</button>
Â  Â  <button class="secondary" id="reset">â†» Ğ¡Ğ±Ñ€Ğ¾Ñ</button>
Â  </div>

Â  <div class="hint">Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: Ñ‚Ğ°Ğ¿ Ğ¿Ğ¾ ÑĞºÑ€Ğ°Ğ½Ñƒ = Ğ¿Ñ€Ñ‹Ğ¶Ğ¾Ğº</div>
</div>

<script>
(() => {
Â  // --- Telegram expand (Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ĞĞ• Ğ±Ñ‹Ğ»Ğ¾ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¾Ğ³Ğ¾ Ğ¾ĞºĞ½Ğ°/ÑĞºÑ€Ğ¾Ğ»Ğ»Ğ°)
Â  try {
Â  Â  if (window.Telegram && Telegram.WebApp) {
Â  Â  Â  Telegram.WebApp.ready();
Â  Â  Â  Telegram.WebApp.expand();
Â  Â  Â  Telegram.WebApp.disableVerticalSwipes?.();
Â  Â  Â  Telegram.WebApp.setHeaderColor?.("#081225");
Â  Â  Â  Telegram.WebApp.setBackgroundColor?.("#081225");
Â  Â  }
Â  } catch(e){}

Â  const canvas = document.getElementById('c');
Â  const ctx = canvas.getContext('2d', { alpha: false });

Â  const $time = document.getElementById('time');
Â  const $dist = document.getElementById('dist');
Â  const $spd Â = document.getElementById('spd');
Â  const $best = document.getElementById('best');

Â  const overlay = document.getElementById('overlay');
Â  const ovDist Â = document.getElementById('ovDist');
Â  const ovReward= document.getElementById('ovReward');
Â  const toast Â  = document.getElementById('toast');

Â  const btnPlay = document.getElementById('play');
Â  const btnReset= document.getElementById('reset');
Â  const btnAgain= document.getElementById('btnAgain');
Â  const btnReset2=document.getElementById('btnReset');

Â  // =========================
Â  // 1) Ğ¡ĞŸĞ ĞĞ™Ğ¢-ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ˜
Â  // =========================
Â  // Ğ¢Ğ£Ğ¢ ĞœĞĞ–Ğ•Ğ¢ ĞŸĞĞ¢Ğ Ğ•Ğ‘ĞĞ’ĞĞ¢Ğ¬Ğ¡Ğ¯ ĞŸĞĞ”ĞĞ“ĞĞĞ¢Ğ¬:
Â  // Ğ•ÑĞ»Ğ¸ ĞºĞ°Ğ´Ñ€Ñ‹ Ñ€ĞµĞ¶ÑƒÑ‚ÑÑ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾ â€” Ğ¿Ğ¾Ğ¼ĞµĞ½ÑĞ¹ FRAME_W / FRAME_H
Â  // (ÑÑ‚Ğ¾ ÑˆĞ¸Ñ€Ğ¸Ğ½Ğ°/Ğ²Ñ‹ÑĞ¾Ñ‚Ğ° Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ°Ğ´Ñ€Ğ° Ğ² Ñ‚Ğ²Ğ¾ĞµĞ¼ archer.png)
Â  const SPRITE_SRC = 'archer.png';

Â  let FRAME_W = 256; // <-- ĞµÑĞ»Ğ¸ Ğ½Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚, Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ğ½Ğ¸
Â  let FRAME_H = 256; // <-- ĞµÑĞ»Ğ¸ Ğ½Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚, Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ğ½Ğ¸

Â  // Ğ¢Ğ’ĞĞ¯ Ğ ĞĞ—ĞœĞ•Ğ¢ĞšĞ:
Â  // Ğ’ĞµÑ€Ñ…Ğ½Ğ¸Ğ¹ Ñ€ÑĞ´: 3 ĞºĞ°Ğ´Ñ€Ğ° Ğ±ĞµĞ³Ğ°
Â  const RUN_FRAMES = [
Â  Â  {x:0, y:0},
Â  Â  {x:1, y:0},
Â  Â  {x:2, y:0},
Â  ];

Â  // Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹ Ñ€ÑĞ´: 2 ĞºĞ°Ğ´Ñ€Ğ° ÑÑ‚Ğ°Ñ€Ñ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ±ĞµĞ³Ğ° (Ğ¿Ñ€Ğ¾Ğ¸Ğ³Ñ€Ñ‹Ğ²Ğ°ĞµĞ¼ 1 Ñ€Ğ°Ğ· Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ°Ñ€Ñ‚Ğµ)
Â  const START_FRAMES = [
Â  Â  {x:0, y:1},
Â  Â  {x:1, y:1},
Â  ];

Â  // ĞĞ¸Ğ¶Ğ½Ğ¸Ğ¹ Ñ€ÑĞ´: 1 ĞºĞ°Ğ´Ñ€ ÑĞ¼ĞµÑ€Ñ‚Ğ¸
Â  const DEATH_FRAME = {x:0, y:2};

Â  // =========================
Â  // 2) Ğ˜Ğ“Ğ Ğ / Ğ¤Ğ˜Ğ—Ğ˜ĞšĞ
Â  // =========================
Â  const state = {
Â  Â  running: false,
Â  Â  gameOver: false,
Â  Â  startedAt: 0,
Â  Â  t: 0,
Â  Â  dist: 0,
Â  Â  speed: 270, // px/sec Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ
Â  Â  speedMul: 1.0,
Â  Â  best: Number(localStorage.getItem('wg_best') || 0),
Â  Â  lastTs: 0,

Â  Â  groundH: 0,
Â  Â  // player
Â  Â  px: 0,
Â  Â  py: 0,
Â  Â  vy: 0,
Â  Â  pw: 0,
Â  Â  ph: 0,
Â  Â  onGround: true,

Â  Â  // obstacles
Â  Â  obstacles: [],
Â  Â  nextSpawnIn: 0, // px
Â  Â  minGapPx: 0,

Â  Â  // animation
Â  Â  spriteLoaded: false,
Â  Â  sprite: null,
Â  Â  animTime: 0,
Â  Â  animMode: 'idle', // 'start' | 'run' | 'death'
Â  Â  startOnceDone: false,

Â  Â  // rewards by meters (Ğ½Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ»Ñ‹ Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ğ¿Ğ¾Ğ¼ĞµĞ½ÑĞµĞ¼)
Â  Â  rewardSteps: [
Â  Â  Â  {m:200, coins:50},
Â  Â  Â  {m:500, coins:100},
Â  Â  Â  {m:1000, coins:250},
Â  Â  Â  {m:2000, coins:500},
Â  Â  Â  {m:3000, coins:800},
Â  Â  Â  {m:5000, coins:2000},
Â  Â  ],
Â  Â  claimed: new Set()
Â  };

Â  $best.textContent = state.best;

Â  function resize() {
Â  Â  const rect = canvas.getBoundingClientRect();
Â  Â  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
Â  Â  canvas.width Â = Math.floor(rect.width * dpr);
Â  Â  canvas.height = Math.floor(rect.height * dpr);
Â  Â  ctx.setTransform(dpr,0,0,dpr,0,0);

Â  Â  // layout based on visible size (CSS pixels)
Â  Â  const W = rect.width;
Â  Â  const H = rect.height;

Â  Â  state.groundH = Math.max(52, Math.round(H * 0.16));
Â  Â  state.px = Math.round(W * 0.14);

Â  Â  // Ğ¸Ğ³Ñ€Ğ¾Ğº Ğ²ÑĞµĞ³Ğ´Ğ° Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ñ‹Ğ¹ Ğ¸ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñƒ
Â  Â  state.ph = Math.round(Math.min(110, Math.max(70, H * 0.18)));
Â  Â  state.pw = Math.round(state.ph * 0.9);

Â  Â  state.py = H - state.groundH - state.ph; // ÑÑ‚Ğ¾Ğ¸Ğ¼ Ğ½Ğ° Ğ·ĞµĞ¼Ğ»Ğµ
Â  Â  state.onGround = true;
Â  Â  state.vy = 0;

Â  Â  // Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ°Ñ Ğ´Ğ¸ÑÑ‚Ğ°Ğ½Ñ†Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¿Ñ€ĞµĞ¿ÑÑ‚ÑÑ‚Ğ²Ğ¸ÑĞ¼Ğ¸ (Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ¾ 5 Ğ¿Ğ¾Ğ´Ñ€ÑĞ´ Ğ±ĞµĞ· ÑˆĞ°Ğ½ÑĞ°)
Â  Â  // Ğ§ĞµĞ¼ Ğ²Ñ‹ÑˆĞµ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ â€” Ñ‚ĞµĞ¼ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ gap
Â  Â  state.minGapPx = Math.round(Math.max(220, W * 0.35));
Â  }
Â  window.addEventListener('resize', resize);

Â  // =========================
Â  // 3) Ğ¡ĞŸĞ ĞĞ™Ğ¢ Ğ—ĞĞ“Ğ Ğ£Ğ—ĞšĞ
Â  // =========================
Â  const img = new Image();
Â  img.onload = () => {
Â  Â  state.spriteLoaded = true;
Â  Â  state.sprite = img;

Â  Â  // ĞµÑĞ»Ğ¸ Ğ¼Ñ‹ Ğ½Ğµ ÑƒĞ³Ğ°Ğ´Ğ°Ğ»Ğ¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹ ĞºĞ°Ğ´Ñ€Ğ° â€” Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚Ğ°Ñ‚ÑŒÑÑ Ğ°Ğ²Ñ‚Ğ¾-ÑƒĞ³Ğ°Ğ´Ğ°Ñ‚ÑŒ
Â  Â  // (Ğ½Ğµ Ğ²ÑĞµĞ³Ğ´Ğ° ÑÑ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚, Ğ½Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°ĞµÑ‚)
Â  Â  // ĞµÑĞ»Ğ¸ Ñ‚Ğ²Ğ¾Ñ ĞºĞ°Ñ€Ñ‚Ğ¸Ğ½ĞºĞ° ÑˆĞ¸Ñ€Ğ¸Ğ½Ğ¾Ğ¹ Ğ´ĞµĞ»Ğ¸Ñ‚ÑÑ Ğ½Ğ° 3 â€” ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼ frameW = width/3
Â  Â  // Ğ° Ğ²Ñ‹ÑĞ¾Ñ‚Ğ¾Ğ¹ Ğ½Ğ° 3 â€” frameH = height/3
Â  Â  if (img.width % 3 === 0) FRAME_W = img.width / 3;
Â  Â  if (img.height % 3 === 0) FRAME_H = img.height / 3;
Â  };
Â  img.src = SPRITE_SRC;

Â  // =========================
Â  // 4) Ğ Ğ•ĞĞ”Ğ•Ğ  Ğ¡ĞŸĞ ĞĞ™Ğ¢Ğ (Ğ²Ñ‹Ñ€ĞµĞ·Ğ°ĞµĞ¼ ĞºĞ°Ğ´Ñ€)
Â  // =========================
Â  function drawFrame(frame, x, y, w, h) {
Â  Â  if (!state.spriteLoaded) {
Â  Â  Â  // fallback ĞºĞ²Ğ°Ğ´Ñ€Ğ°Ñ‚, ĞµÑĞ»Ğ¸ ÑĞ¿Ñ€Ğ°Ğ¹Ñ‚ Ğ½Ğµ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ğ»ÑÑ
Â  Â  Â  ctx.fillStyle = '#fff';
Â  Â  Â  ctx.fillRect(x, y, w, h);
Â  Â  Â  return;
Â  Â  }
Â  Â  const sx = frame.x * FRAME_W;
Â  Â  const sy = frame.y * FRAME_H;
Â  Â  ctx.drawImage(state.sprite, sx, sy, FRAME_W, FRAME_H, x, y, w, h);
Â  }

Â  function getAnimFrame(dt) {
Â  Â  state.animTime += dt;

Â  Â  const fpsRun = 10; Â  Â  // ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸
Â  Â  const fpsStart = 8;

Â  Â  if (state.animMode === 'death') return DEATH_FRAME;

Â  Â  if (state.animMode === 'start') {
Â  Â  Â  const idx = Math.floor(state.animTime * fpsStart);
Â  Â  Â  if (idx >= START_FRAMES.length) {
Â  Â  Â  Â  state.animMode = 'run';
Â  Â  Â  Â  state.animTime = 0;
Â  Â  Â  Â  return RUN_FRAMES[0];
Â  Â  Â  }
Â  Â  Â  return START_FRAMES[idx];
Â  Â  }

Â  Â  // run
Â  Â  const ridx = Math.floor(state.animTime * fpsRun) % RUN_FRAMES.length;
Â  Â  return RUN_FRAMES[ridx];
Â  }

Â  // =========================
Â  // 5) ĞŸĞ Ğ•ĞŸĞ¯Ğ¢Ğ¡Ğ¢Ğ’Ğ˜Ğ¯
Â  // =========================
Â  function spawnObstacle(W, H) {
Â  Â  const base = Math.max(26, Math.round(H * 0.08));
Â  Â  const height = base + Math.round(Math.random() * base);
Â  Â  const width Â = Math.max(18, Math.round(base * 0.55));

Â  Â  const x = W + 20;
Â  Â  const y = H - state.groundH - height;

Â  Â  state.obstacles.push({ x, y, w: width, h: height });
Â  }

Â  function setNextSpawn(W) {
Â  Â  // Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ€Ğ°Ğ·Ğ±Ñ€Ğ¾Ñ, Ğ½Ğ¾ ÑĞ¾Ğ±Ğ»ÑĞ´Ğ°ĞµĞ¼ minGap
Â  Â  const extra = Math.round(Math.random() * (W * 0.25));
Â  Â  state.nextSpawnIn = state.minGapPx + extra;
Â  }

Â  // =========================
Â  // 6) Ğ›ĞĞ“Ğ˜ĞšĞ / ĞšĞĞ›Ğ›Ğ˜Ğ—Ğ˜Ğ˜
Â  // =========================
Â  function jump() {
Â  Â  if (!state.running || state.gameOver) return;
Â  Â  if (!state.onGround) return;

Â  Â  state.onGround = false;
Â  Â  state.vy = -720; // Ğ¿Ñ€Ñ‹Ğ¶Ğ¾Ğº (px/sec)
Â  }

Â  function rectsHit(a, b) {
Â  Â  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
Â  }

Â  function endGame() {
Â  Â  if (state.gameOver) return;
Â  Â  state.gameOver = true;
Â  Â  state.running = false;
Â  Â  state.animMode = 'death';
Â  Â  state.animTime = 0;

Â  Â  // UI
Â  Â  ovDist.textContent = Math.floor(state.dist);
Â  Â  ovReward.textContent = '';
Â  Â  overlay.classList.add('show');

Â  Â  // Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ² Ğ±Ğ¾Ñ‚Ğ°
Â  Â  // Telegram.WebApp.sendData(JSON.stringify({type:'run_end', meters: Math.floor(state.dist)}));
Â  }

Â  // Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñ‹ Ğ¿Ğ¾ Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼ (Ğ¿Ğ¾ĞºĞ° â€œĞ½Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ»Ñ‹â€, Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ğ¿Ğ¾Ğ¼ĞµĞ½ÑĞµĞ¼)
Â  function checkRewards() {
Â  Â  const meters = Math.floor(state.dist);
Â  Â  for (const r of state.rewardSteps) {
Â  Â  Â  if (meters >= r.m && !state.claimed.has(r.m)) {
Â  Â  Â  Â  state.claimed.add(r.m);
Â  Â  Â  Â  showToast(`âœ… ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: +${r.coins} Ğ¼Ğ¾Ğ½ĞµÑ‚ (Ğ·Ğ° ${r.m}Ğ¼)`);
Â  Â  Â  Â  // Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ñ‚ÑƒÑ‚ Ğ±ÑƒĞ´ĞµÑ‚ Telegram.WebApp.sendData(...)
Â  Â  Â  }
Â  Â  }
Â  }

Â  let toastTimer = null;
Â  function showToast(text) {
Â  Â  toast.textContent = text;
Â  Â  toast.classList.add('show');
Â  Â  clearTimeout(toastTimer);
Â  Â  toastTimer = setTimeout(()=>toast.classList.remove('show'), 1700);
Â  }

Â  function resetGame(full = false) {
Â  Â  overlay.classList.remove('show');
Â  Â  state.running = false;
Â  Â  state.gameOver = false;
Â  Â  state.t = 0;
Â  Â  state.dist = 0;
Â  Â  state.speedMul = 1.0;
Â  Â  state.animTime = 0;
Â  Â  state.animMode = 'idle';
Â  Â  state.startOnceDone = false;
Â  Â  state.obstacles = [];
Â  Â  state.claimed = new Set();

Â  Â  if (full) {
Â  Â  Â  state.best = 0;
Â  Â  Â  localStorage.setItem('wg_best', '0');
Â  Â  Â  $best.textContent = '0';
Â  Â  }
Â  Â  $time.textContent = '0.0';
Â  Â  $dist.textContent = '0';
Â  Â  $spd.textContent Â = '1.0';
Â  }

Â  function startGame() {
Â  Â  overlay.classList.remove('show');
Â  Â  state.running = true;
Â  Â  state.gameOver = false;
Â  Â  state.startedAt = performance.now();
Â  Â  state.lastTs = performance.now();
Â  Â  state.animMode = 'start';
Â  Â  state.animTime = 0;
Â  Â  state.obstacles = [];
Â  Â  setNextSpawn(canvas.getBoundingClientRect().width);
Â  }

Â  // =========================
Â  // 7) UPDATE LOOP
Â  // =========================
Â  function loop(ts) {
Â  Â  requestAnimationFrame(loop);

Â  Â  const rect = canvas.getBoundingClientRect();
Â  Â  const W = rect.width;
Â  Â  const H = rect.height;

Â  Â  if (!W || !H) return;

Â  Â  const dt = Math.min(0.033, (ts - (state.lastTs || ts)) / 1000);
Â  Â  state.lastTs = ts;

Â  Â  // Ñ„Ğ¾Ğ½
Â  Â  ctx.fillStyle = '#071024';
Â  Â  ctx.fillRect(0,0,W,H);

Â  Â  // Ğ·ĞµĞ¼Ğ»Ñ
Â  Â  ctx.fillStyle = 'rgba(255,255,255,.08)';
Â  Â  ctx.fillRect(0, H - state.groundH, W, state.groundH);

Â  Â  // ĞµÑĞ»Ğ¸ Ğ¸Ğ³Ñ€Ğ° Ğ¸Ğ´ĞµÑ‚ â€” Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ„Ğ¸Ğ·Ğ¸ĞºÑƒ
Â  Â  if (state.running && !state.gameOver) {
Â  Â  Â  state.t += dt;
Â  Â  Â  const pxPerSec = state.speed * state.speedMul;
Â  Â  Â  state.dist += (pxPerSec * dt) / 6; // ~Ğ¼ĞµÑ‚Ñ€Ñ‹ (ÑƒÑĞ»Ğ¾Ğ²Ğ½Ğ¾, Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ´Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ)
Â  Â  Â  state.speedMul = Math.min(2.2, 1.0 + state.dist / 3000); // Ğ¿Ğ¾ÑÑ‚ĞµĞ¿ĞµĞ½Ğ½Ğ¾ ÑƒÑĞºĞ¾Ñ€ÑĞµĞ¼

Â  Â  Â  // Ğ³Ñ€Ğ°Ğ²Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ
Â  Â  Â  state.vy += 1900 * dt;
Â  Â  Â  state.py += state.vy * dt;

Â  Â  Â  const groundY = H - state.groundH - state.ph;
Â  Â  Â  if (state.py >= groundY) {
Â  Â  Â  Â  state.py = groundY;
Â  Â  Â  Â  state.vy = 0;
Â  Â  Â  Â  state.onGround = true;
Â  Â  Â  }

Â  Â  Â  // Ğ¿Ñ€ĞµĞ¿ÑÑ‚ÑÑ‚Ğ²Ğ¸Ñ Ğ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼
Â  Â  Â  const dx = pxPerSec * dt;
Â  Â  Â  for (const ob of state.obstacles) ob.x -= dx;
Â  Â  Â  state.obstacles = state.obstacles.filter(ob => ob.x + ob.w > -40);

Â  Â  Â  // ÑĞ¿Ğ°Ğ²Ğ½ Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğ¼ gap
Â  Â  Â  state.nextSpawnIn -= dx;
Â  Â  Â  if (state.nextSpawnIn <= 0) {
Â  Â  Â  Â  spawnObstacle(W, H);
Â  Â  Â  Â  setNextSpawn(W);
Â  Â  Â  }

Â  Â  Â  // ĞºĞ¾Ğ»Ğ»Ğ¸Ğ·Ğ¸Ñ
Â  Â  Â  const playerRect = { x: state.px + 6, y: state.py + 6, w: state.pw - 12, h: state.ph - 10 };
Â  Â  Â  for (const ob of state.obstacles) {
Â  Â  Â  Â  const obRect = { x: ob.x, y: ob.y, w: ob.w, h: ob.h };
Â  Â  Â  Â  if (rectsHit(playerRect, obRect)) {
Â  Â  Â  Â  Â  endGame();
Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  checkRewards();

Â  Â  Â  // UI
Â  Â  Â  $time.textContent = state.t.toFixed(1);
Â  Â  Â  $dist.textContent = Math.floor(state.dist);
Â  Â  Â  $spd.textContent Â = state.speedMul.toFixed(1);
Â  Â  }

Â  Â  // Ñ€Ğ¸ÑÑƒĞµĞ¼ Ğ¿Ñ€ĞµĞ¿ÑÑ‚ÑÑ‚Ğ²Ğ¸Ñ
Â  Â  ctx.fillStyle = 'rgba(255,80,80,.85)';
Â  Â  for (const ob of state.obstacles) {
Â  Â  Â  ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
Â  Â  }

Â  Â  // Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ°Ğ´Ñ€ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ°
Â  Â  let frame;
Â  Â  if (state.gameOver) {
Â  Â  Â  frame = DEATH_FRAME;
Â  Â  } else if (!state.running) {
Â  Â  Â  // ÑÑ‚Ğ¾Ğ¸Ğ¼ (Ğ¿Ğ¾ĞºĞ°Ğ¶ĞµĞ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ±ĞµĞ³Ğ¾Ğ²Ğ¾Ğ¹ ĞºĞ°Ğ´Ñ€)
Â  Â  Â  frame = RUN_FRAMES[0];
Â  Â  Â  state.animTime = 0;
Â  Â  } else {
Â  Â  Â  if (state.animMode === 'idle') state.animMode = 'start';
Â  Â  Â  frame = getAnimFrame(dt);
Â  Â  }

Â  Â  drawFrame(frame, state.px, state.py, state.pw, state.ph);

Â  Â  // best
Â  Â  const metersNow = Math.floor(state.dist);
Â  Â  if (metersNow > state.best) {
Â  Â  Â  state.best = metersNow;
Â  Â  Â  localStorage.setItem('wg_best', String(state.best));
Â  Â  Â  $best.textContent = String(state.best);
Â  Â  }
Â  }

Â  // =========================
Â  // 8) INPUT: Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ¢ĞĞŸ
Â  // =========================
Â  function onTap(e){
Â  Â  e.preventDefault();
Â  Â  if (!state.running && !state.gameOver) startGame();
Â  Â  else jump();
Â  }

Â  // Ğ¢Ğ°Ğ¿ Ğ¿Ğ¾ Ğ·Ğ¾Ğ½Ğµ Ğ¸Ğ³Ñ€Ñ‹
Â  document.getElementById('gameWrap').addEventListener('touchstart', onTap, {passive:false});
Â  document.getElementById('gameWrap').addEventListener('click', (e)=>{ e.preventDefault(); onTap(e); });

Â  // ĞšĞ½Ğ¾Ğ¿ĞºĞ¸
Â  btnPlay.addEventListener('click', () => startGame());
Â  btnAgain.addEventListener('click', () => startGame());
Â  btnReset.addEventListener('click', () => resetGame(false));
Â  btnReset2.addEventListener('click', () => resetGame(false));

Â  // init
Â  resize();
Â  resetGame(false);
Â  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
