<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>WG Archer Run</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    html, body { margin:0; height:100%; background:#071a33; overflow:hidden; font-family: system-ui, -apple-system, Arial; }
    #root{ position:fixed; inset:0; background: linear-gradient(#0b2548,#071a33); }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    /* Кнопки — чтобы точно были видны */
    #btnBar{
      position:absolute; left:12px; right:12px;
      bottom: calc(14px + env(safe-area-inset-bottom));
      display:flex; gap:10px; justify-content:center;
      z-index:50;
      pointer-events:auto;
    }
    button{
      border:0; border-radius:16px; padding:12px 16px;
      font-size:16px; font-weight:1000;
      background:#6aa5ff; color:#071a33;
    }
    button.secondary{ background: rgba(255,255,255,.14); color:#fff; border:1px solid rgba(255,255,255,.18); }
  </style>
</head>

<body>
<div id="root">
  <canvas id="c"></canvas>

  <div id="btnBar">
    <button id="btnStart">Играть</button>
    <button id="btnTop" class="secondary">ТОП</button>
    <button id="btnReset" class="secondary">Сброс</button>
  </div>
</div>

<script>
/* Telegram */
try{
  Telegram.WebApp.ready();
  Telegram.WebApp.expand();
  Telegram.WebApp.disableVerticalSwipes?.();
} catch(e){}

/* Определяем: внутри Telegram или нет */
const TG_ID = Telegram.WebApp?.initDataUnsafe?.user?.id || null;
const IS_TG = !!TG_ID;

/* Canvas */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

/* Стабильный размер под Telegram/iOS */
let W = 0, H = 0, DPR = 1;

function getStableSize(){
  let w = Math.floor(window.innerWidth);
  let h = Math.floor(window.innerHeight);

  try{
    const vsh = Telegram.WebApp?.viewportStableHeight;
    if (typeof vsh === "number" && vsh > 0) h = Math.floor(vsh);
  } catch(e){}

  w = Math.max(320, w);
  h = Math.max(420, h);
  return {w,h};
}

function resize(){
  const s = getStableSize();
  W = s.w; H = s.h;
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // чтобы не раздувало на iPhone

  canvas.style.width = W + "px";
  canvas.style.height = H + "px";
  canvas.width = Math.floor(W * DPR);
  canvas.height = Math.floor(H * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener("resize", resize);
resize();

/* Build marker */
const BUILD = "BUILD 2026-02-21 v3";

/* Helpers for per-user storage keys */
function key(name){
  return `wg_${name}_${IS_TG ? TG_ID : "demo"}`;
}

/* Storage */
let best = Number(localStorage.getItem(key("best_m")) || 0);
let lb = JSON.parse(localStorage.getItem(key("lb10")) || "[]"); // [{m,ts}]
let claimedRewards = new Set(JSON.parse(localStorage.getItem(key("claimed")) || "[]"));

/* ВАЖНО:
   Монеты для игры НЕ храним локально (чтобы не было "баланс мини-игры").
   На демо-сайте просто показываем DEMO и 0.
   В Telegram при выдаче награды — отправляем в бота через sendData().
*/
let coinsShown = 0;  // то, что рисуем (в демо = 0)
let coinsDemo = Number(localStorage.getItem(key("coins_demo")) || 0); // только для демо, если хочешь тестить

/* UI buttons */
const btnStart = document.getElementById("btnStart");
const btnTop   = document.getElementById("btnTop");
const btnReset = document.getElementById("btnReset");

/* Game state */
let state = "menu"; // menu | play | top | over
let distance = 0;
let earnedThisRun = 0;

/* Physics */
const GROUND_H = 120;
const GRAVITY = 2700;
const JUMP_V  = 980;

function groundY(){ return H - GROUND_H; }

const player = {
  x: 90, y: 0,
  w: 84, h: 84,
  vy: 0,
  onGround: true,
  animT: 0
};

/* Sprite sheet 3x3 */
const sprite = new Image();
sprite.src = "archer.png";
let spriteReady = false;
let frameW = 0, frameH = 0;

sprite.onload = () => {
  spriteReady = true;
  frameW = Math.floor(sprite.width / 3);
  frameH = Math.floor(sprite.height / 3);
};

function drawSprite(row, col, x, y, w, h){
  if(!spriteReady){
    ctx.fillStyle = "#fff";
    ctx.fillRect(x,y,w,h);
    return;
  }
  const sx = col * frameW;
  const sy = row * frameH;
  ctx.drawImage(sprite, sx, sy, frameW, frameH, x, y, w, h);
}

/* Obstacles */
const obstacles = [];
let spawnTimer = 0;

function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function gapSeconds(){
  const t = clamp(distance / 3500, 0, 1);
  const minS = 1.1 - 0.45*t;   // 1.1 -> 0.65
  const maxS = 1.8 - 0.55*t;   // 1.8 -> 1.25
  return minS + Math.random() * (maxS - minS);
}

function spawnObstacle(){
  const w = 54;
  const h = randInt(75, 140);
  obstacles.push({
    x: W + 80,
    y: groundY() - h,
    w, h
  });
}

/* Rewards */
const rewards = [
  { m: 200,  coins: 50  },
  { m: 500,  coins: 120 },
  { m: 1000, coins: 300 },
  { m: 2000, coins: 700 }
];

function saveClaimed(){
  localStorage.setItem(key("claimed"), JSON.stringify([...claimedRewards]));
}

/* HUD flash */
let flashText = "";
let flashT = 0;

/* Speed */
let BASE_SPEED = 520;

function resetRun(){
  distance = 0;
  earnedThisRun = 0;

  player.y = groundY() - player.h;
  player.vy = 0;
  player.onGround = true;
  player.animT = 0;

  obstacles.length = 0;

  spawnTimer = 0.8; // быстрое первое препятствие
  BASE_SPEED = 520;
}

function startGame(){
  state = "play";
  resetRun();
}

function endGame(){
  state = "over";
  const m = Math.floor(distance);

  if(m > best){
    best = m;
    localStorage.setItem(key("best_m"), String(best));
  }

  lb.push({ m, ts: Date.now() });
  lb.sort((a,b)=>b.m-a.m);
  lb = lb.slice(0,10);
  localStorage.setItem(key("lb10"), JSON.stringify(lb));
}

/* Выдача наград:
   - только в Telegram
   - только 1 раз за весь ивент на TG_ID (claimedRewards в localStorage по TG_ID)
   - в демо (вне Telegram) не выдаём вообще
*/
function checkRewards(){
  if(!IS_TG){
    return; // вне Telegram наград нет
  }

  for(const r of rewards){
    const rewardKey = String(r.m);
    if(distance >= r.m && !claimedRewards.has(rewardKey)){
      claimedRewards.add(rewardKey);
      saveClaimed();

      earnedThisRun += r.coins;

      // отправляем в бота (бот добавит в ОБЩИЙ баланс)
      try{
        Telegram.WebApp.sendData(JSON.stringify({
          type: "add_coins",
          amount: r.coins,
          reason: "wg_archer_run",
          milestone_m: r.m
        }));
      }catch(e){}

      flashText = `+${r.coins} монет за ${r.m}м (1 раз)`;
      flashT = 1.2;
    }
  }
}

/* Input: TAP only */
function tap(e){
  try{ e.preventDefault?.(); }catch(_){}
  if(state === "menu" || state === "over"){ startGame(); return; }
  if(state !== "play") return;
  if(player.onGround){
    player.vy = -JUMP_V;
    player.onGround = false;
  }
}
window.addEventListener("touchstart", tap, { passive:false });
window.addEventListener("pointerdown", tap, { passive:false });

/* Buttons */
btnStart.onclick = () => startGame();

btnTop.onclick = () => {
  state = (state === "top") ? "menu" : "top";
};

btnReset.onclick = () => {
  localStorage.removeItem(key("best_m"));
  localStorage.removeItem(key("lb10"));
  localStorage.removeItem(key("claimed"));
  localStorage.removeItem(key("coins_demo"));
  best = 0; lb = [];
  claimedRewards = new Set();
  coinsDemo = 0;
  state = "menu";
};

/* Draw helpers */
function drawTextBox(x,y,w,h){
  ctx.fillStyle = "rgba(0,0,0,.55)";
  ctx.fillRect(x,y,w,h);
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);
}

/* Адаптивные размеры шрифтов (чтобы НЕ было огромного текста на айфонах/андроидах) */
function uiScale(){
  const base = clamp(Math.floor(Math.min(W, H) / 24), 14, 22); // 14..22
  return base;
}

let last = performance.now();

function loop(now){
  const dt = Math.min(0.033, (now-last)/1000);
  last = now;

  // background
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "rgba(0,0,0,0.10)";
  ctx.fillRect(0,0,W,H);

  // ground
  ctx.fillStyle = "rgba(20,45,75,0.95)";
  ctx.fillRect(0, groundY(), W, GROUND_H);

  const s = uiScale();
  const safeTop = 12 + (window.visualViewport?.offsetTop || 0);

  // BUILD
  ctx.font = `700 ${Math.max(12, Math.floor(s*0.85))}px system-ui, -apple-system, Arial`;
  ctx.fillStyle = "rgba(255,255,255,.92)";
  ctx.fillText(BUILD + (IS_TG ? "" : "  DEMO"), 12, safeTop + 16);

  // Coins shown:
  // - в Telegram мы рисуем 0 (или то, что ты потом будешь передавать из бота)
  // - вне Telegram демо — тоже 0
  // Если хочешь тестить демо начисления — раскомментируй ниже и используй coinsDemo
  coinsShown = 0;

  if(state === "play" || state === "over"){
    ctx.font = `900 ${Math.floor(s*1.25)}px system-ui, -apple-system, Arial`;
    ctx.fillText(`Дистанция: ${Math.floor(distance)} м`, 12, safeTop + 46);
    ctx.fillText(`Рекорд: ${best} м`, 12, safeTop + 46 + Math.floor(s*1.35));
    ctx.fillText(`Монеты: ${coinsShown}`, 12, safeTop + 46 + Math.floor(s*2.7));
  }

  if(flashT > 0){
    flashT -= dt;
    ctx.font = `1000 ${Math.floor(s*1.15)}px system-ui, -apple-system, Arial`;
    ctx.fillStyle = "rgba(255,255,255,.98)";
    ctx.fillText(flashText, 12, safeTop + 46 + Math.floor(s*4.1));
  }

  if(state === "top"){
    drawTextBox(12, safeTop + 58, Math.min(520, W-24), 320);
    ctx.fillStyle = "#fff";
    ctx.font = `1000 ${Math.floor(s*1.25)}px system-ui, -apple-system, Arial`;
    ctx.fillText("ТОП-10", 24, safeTop + 90);

    ctx.font = `900 ${Math.floor(s*1.05)}px system-ui, -apple-system, Arial`;
    if(lb.length === 0){
      ctx.fillText("Пока пусто — сыграй первый раз.", 24, safeTop + 126);
    } else {
      for(let i=0;i<lb.length;i++){
        ctx.fillText(`#${i+1} — ${lb[i].m} м`, 24, safeTop + 126 + i*Math.floor(s*1.35));
      }
    }
    requestAnimationFrame(loop);
    return;
  }

  // speed growth
  const speedMul = 1 + Math.min(1.2, distance / 2200);
  const worldSpeed = BASE_SPEED * speedMul;

  if(state === "play"){
    distance += (worldSpeed * dt) / 6.8;

    // spawn by timer
    spawnTimer -= dt;
    if(spawnTimer <= 0){
      spawnObstacle();
      spawnTimer = Math.max(0.65, gapSeconds());
    }

    // physics
    player.vy += GRAVITY * dt;
    player.y += player.vy * dt;

    const gy = groundY() - player.h;
    if(player.y >= gy){
      player.y = gy;
      player.vy = 0;
      player.onGround = true;
    }

    // move obstacles
    for(let i = obstacles.length-1; i>=0; i--){
      obstacles[i].x -= worldSpeed * dt;
      if(obstacles[i].x + obstacles[i].w < -200) obstacles.splice(i,1);
    }

    // collisions
    const px1 = player.x + 12, px2 = player.x + player.w - 12;
    const py1 = player.y + 8,  py2 = player.y + player.h - 4;

    for(const o of obstacles){
      const ox1 = o.x + 8, ox2 = o.x + o.w - 8;
      const oy1 = o.y + 4, oy2 = o.y + o.h;
      const hit = !(px2 < ox1 || px1 > ox2 || py2 < oy1 || py1 > oy2);
      if(hit){ endGame(); break; }
    }

    checkRewards();
  }

  // draw obstacles
  ctx.fillStyle = "#e04646";
  for(const o of obstacles){
    ctx.fillRect(o.x, o.y, o.w, o.h);
  }

  // draw player animation: row0 run, row1 jump, row2 death
  let row=0, col=0;
  if(state === "over"){ row=2; col=0; }
  else if(!player.onGround){ row=1; col=0; }
  else {
    player.animT += dt;
    col = Math.floor((player.animT * 10) % 3);
    row = 0;
  }
  drawSprite(row, col, player.x, player.y, player.w, player.h);

  // game over
  if(state === "over"){
    drawTextBox(12, safeTop + Math.floor(s*6.2), Math.min(520, W-24), Math.floor(s*6));
    ctx.fillStyle = "#fff";
    ctx.font = `1000 ${Math.floor(s*1.5)}px system-ui, -apple-system, Arial`;
    ctx.fillText("GAME OVER", 24, safeTop + Math.floor(s*7.5));
    ctx.font = `900 ${Math.floor(s*1.05)}px system-ui, -apple-system, Arial`;
    ctx.fillText(`Забег: ${Math.floor(distance)} м  |  +${earnedThisRun} монет`, 24, safeTop + Math.floor(s*8.9));
    ctx.fillText("Тап — начать заново", 24, safeTop + Math.floor(s*10.2));
  }

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
